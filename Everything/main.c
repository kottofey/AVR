/* MCU: ATMega16A
 * F_CPU 8000000L
 *
 * Фьюзы:
 * 	High:	0xd7
 * 	Low:	0xc4
 */

/*
 * Todo
 * V- Сделать настройки для подключения периферии дефайнами, для универсальности
 * V- дополнить и изучить функциональность темп. датчика
 * V- сделать прием в UART (!!!)
 * V- задефайнить настройки LCD, сделать их словами, а не хексом
 * V- Попробовать залить символ в LCD массивом, может будет компактнее в памяти
 * N- Повесить вывод температуры на кнопку через внешнее прерывание
 * V- Сделать софтовый анти-дребезг кнопок (счетчик дребезжания?..)
 * V- Дополнить отсутствующие комментарии, а то запутаюсь!
 * V- Залить это дело в GitHub? Опять же, запутаюсь. Да и бэкапы не помешают.
 * V- Переделать под конечный автомат
 * V- Перевести LCD в 4х-битный режим. ДАЕШЬ МЕНЬШЕ ПРОВОДОВ!!!
 * 	- Инициализация UART через параметры функции
 * V- Прикрутить каким-нибудь образом sleep mode
 * V- Чтение байта из под курсора на LCD
 * ~- Поиск всех устройств 1-wire (команда SEARCH_ROM)
 * ~- Поиск всех устройств 1-wire с алармом (команда ALARM_SEARCH)
 * V- Сделать выключаемую и настраиваемую подсветку LCD (выкл по таймеру)
 * V- идея для сна: повесить клавиатуру на пин с прерыванием, в сон вводить вручную,
 *  	выводить по нажатию клавиши. Во сне отключать ВСЁ... Можно настроить сон по таймауту.
 *  	Можно (и, наверное, нужно) сделать вывод из сна по одной определенной клавише. Иначе прерывания закончатся.
 *  - Допилить функцию DS_SearchROM() не-дома, когда будет больше одного устройства 1-wire.
 *  	Пока что вроде как работает, но выводит в УАРТ по несколько раз одно и то же...
 */
#define F_CPU 8000000L

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>

#include "Timers.h"		// Библиотека таймеров Конечного Автомата (КА)
#include "Messages.h"	// Библиотека сообщений КА
#include "keyboard.h"	// Библиотека клавиатуры КА

#include "my_uart.h"
#include "DS18B20.h"
#include "LCD.h"
#include "menu.h"

ISR (TIMER2_OVF_vect){
	ProcessTimers();		// добавляем единичку ко всем виртуальным таймерам по переполнению и по условию (для секунд-минут итд)
}

ISR (INT1_vect){
	LCD_WriteCmd(LCD_CLEAR_SCREEN);
	LCD_WriteStringFlash(PSTR("Wake up!"));
}


int main(void) {
	UART_Init(MYUBRR);
	LCD_init();
	InitTimers();
	InitMessages();
	DS_InitFSM();
	LCD_InitFSM();
	Keyb_InitFSM();
	SET_MENU_WRITE_FUNC(LCD_WriteStringFlash);
//	SET_MENU_WRITE_FUNC(UART_TxStringFlash);

/////////// Установка лимитов алармы//////////////
//	DS_Reset();
//	DS_WriteByte(SKIP_ROM);
//	DS_WriteByte(WRITE_SCRATCHPAD);
//	DS_WriteByte(0x1E);			// Th - байт (1E = +30ºC)
//	DS_WriteByte(0x00);			// Tl - байт
//	DS_WriteByte(0b01111111);	// Config - байт
//////////////////////////////////////////////////

// Инициализация аппаратного таймера
	TCCR2 = (1 << CS22) | (1 << CS21) | (0 << CS20);	// Prescaler 256, один тик длится 0.032мс при частоте камня 8МГц
	TCNT2 = (255 - 125);	// Обнуляем счетчик. Начинаем тикать 125 раз.
							// За 125 тиков до переполнения пройдет 4мс. Одна секунда длится 250 переполнений.
	TIMSK = 1 << TOIE2;		// Запуск прерывания по переполнению таймера

	MCUCR = 0b01100000;		// SM[2..0] = 010 -> Power Down sleep mode
							// SE = 1 -> Sleep Enabled
							// ISC[11..10] = 00 -> INT1 interrupt on low level

	asm("sei");	// Разрешаем прерывания

	while (1) {
		LCD_ProcessFSM();
		DS_ProcessFSM();
		Keyb_ProcessFSM();
		ProcessMessages();
	}

	return 0;	// Мы никогда не достигнем этого места...
}
